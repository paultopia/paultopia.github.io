<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://paultopia.github.io' rel='self' type='application/rss+xml'/>
<title>
Experiments in Tech Blogging (!!)
</title>
<link>
http://paultopia.github.io
</link>
<description>
let's see, eh?
</description>
<lastBuildDate>
Sat, 03 Dec 2016 14:42:16 -0600
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
http://paultopia.github.io/posts-output/devcards-testing/
</guid>
<link>
http://paultopia.github.io/posts-output/devcards-testing/
</link>
<title>
Devcards for Testing Clojurescript Projects: A Beginner Introduction
</title>
<description>
 &lt;p&gt;Devcards is an amazing library that basically lets you create a separate test build of a Clojurescript project.  &lt;a href='http://rigsomelight.com/devcards/#!/devdemos.testing'&gt;The documentation&lt;/a&gt; is pretty clear, but if you're a relative Clojurescript beginner like me, you'll need a little bit more hand-holding. So here's my mini-walkthrough for getting Devcards integrated into a CLJS project, targeted at people who know the basics. (Recommended background knowledge: can set up a small Clojurescript project, perhaps with help of a lein template, and get it to compile. It will also help to &lt;a href='http://blog.jayfields.com/2010/08/clojuretest-introduction.html'&gt;know how testing works&lt;/a&gt; on JVM Clojure-side with clojure.test.).   &lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;why?&quot;&gt;&lt;/a&gt;Why?&lt;/h2&gt; &lt;p&gt;Clojurescript testing is hard. Or, at least, it seems hard. Honestly, I haven't gotten to the point of figuring out how to make it work yet. Unlike JVM Clojure where you can just use clojure.test and set up some deftests and then just run them with lein test, Clojurescript testing requires setting up some browser environment (or, I guess, Node or something?) to run it in.  Most non-Devcards techniques &lt;a href='https://github.com/bensu/doo#setting-up-environments'&gt;seem to require you&lt;/a&gt; to do extreme yak-shavey things like set up Phantom.js.  &lt;/p&gt;&lt;p&gt;By contrast, Devcards just lets you set up &quot;cards,&quot; that only show up in special builds, and that demonstrate their functionality on a convenient little webpage. So then when you want to do unit testing on your Clojurescript app, you just compile the Devcards build, open up the special Devcards webpage, and then look to make sure everything is working as expected. Your test run is opening a webpage. (And if you have Figwheel going, then you get live test reloading on that webpage.) &lt;/p&gt;&lt;p&gt;You can have an ordinary test, which displays on the web much like it displays when running lein test (i.e., you can see what passed and what failed), and you can also use a &quot;card,&quot; which is just a snippet of code that gets executed and displayed, and is useful for &quot;testing&quot; stuff that requires direct visual examination. (For example, I'm working on a browser extension that uses &lt;a href='https://gionkunz.github.io/chartist-js/'&gt;Chartist.js&lt;/a&gt; to display data vis, and I'm just &lt;a href='https://github.com/paultopia/browser-stats/commit/b6936f8466aba7b0c1695139bbd5c4fe6773ee2f'&gt;defining cards in a test namespace&lt;/a&gt; to allow me to eyeball test charts and make sure they look like I expect.)&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;setup&quot;&gt;&lt;/a&gt;Setup&lt;/h2&gt;&lt;p&gt;Of course you're going to want to require Devcards in your Leiningen dependencies (or do whatever it is that the Boot folks do). More importantly, you're also going to want to set up a separate build in your project.clj.  Here's what the builds section of my project.clj looks like (this is based off the awesome &lt;a href='https://github.com/reagent-project/reagent-frontend-template'&gt;reagent frontend template&lt;/a&gt;, which I basically use for everything, and then add devcards on my own. Hmm... maybe there's a PR or a fork in here...)&lt;/p&gt;&lt;pre&gt;&lt;code&gt;:cljsbuild {:builds {:app
                       {:source-paths &amp;#91;&amp;quot;src&amp;quot; &amp;quot;env/dev/cljs&amp;quot;&amp;#93;
                        :compiler
                        {:main &amp;quot;statspop.dev&amp;quot;
                         :output-to &amp;quot;public/js/app.js&amp;quot;
                         :output-dir &amp;quot;public/js/out&amp;quot;
                         :asset-path   &amp;quot;js/out&amp;quot;
                         :source-map true
                         :optimizations :none
                         :pretty-print  true}}
                       :devcards
                       {:source-paths &amp;#91;&amp;quot;src&amp;quot; &amp;quot;env/dev/cljs&amp;quot; &amp;quot;test&amp;quot;&amp;#93;
                        :figwheel
                        {:devcards true}
                        :compiler
                        { :main       &amp;quot;statspop.dev&amp;quot;
                         :asset-path &amp;quot;js/devcards&amp;#95;out&amp;quot;
                         :output-to  &amp;quot;public/js/devcards.js&amp;quot;
                         :output-dir &amp;quot;public/js/devcards&amp;#95;out&amp;quot;
                         :optimizations :none
                         :source-map-timestamp true }}
                       :release
                       {:source-paths &amp;#91;&amp;quot;src&amp;quot; &amp;quot;env/prod/cljs&amp;quot;&amp;#93;
                        :compiler
                        {:output-to &amp;quot;public/js/app.js&amp;quot;
                         :output-dir &amp;quot;public/js/release&amp;quot;
                         :asset-path   &amp;quot;js/out&amp;quot;
                         :optimizations :advanced
                         :pretty-print false}}}}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note the devcards build in the middle.  That's where the action happens. &lt;/p&gt;&lt;ul&gt;&lt;li&gt;First, note that it has &quot;test&quot; as a source path, in addition to the other paths. That's where I've defined the cards.&lt;/li&gt;&lt;li&gt;Second, note that it has a Figwheel option in the map with &lt;code&gt;{:devcards true}&lt;/code&gt;.  You can use Devcards without Figwheel, but why are you building Clojurescript projects without Figwheel? (Also, Devcards and Figwheel were written by the same &lt;a href='http://rigsomelight.com/'&gt;awesome person&lt;/a&gt;, so they're really good at working together.)&lt;/li&gt;&lt;li&gt;Third, note that it compiles to a totally different Javascript file. It goes to devcards.js rather than app.js. The implication here is that you put your devcards on a totally different html page too. So in the statspop project above, I have index.html in the target &quot;public&quot; directory, which contains the ordinary app (and will actually go away for prod, since this is to be a Chrome extension), but I also have cards.html, which, in relevant part, is just:&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
	&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;css/chartist.min.css&amp;quot;&amp;gt;
	&amp;lt;script src=&amp;quot;js/jstat.min.js&amp;quot; type=&amp;quot;text/javascript&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
	 &amp;lt;script src=&amp;quot;js/chartist.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;script src=&amp;quot;js/devcards.js&amp;quot; type=&amp;quot;text/javascript&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note how that html just calls the Javascript and CSS libraries I'll be using (this may change, depending on how you set up external dependencies, using CLJSJS etc.), and then calls the devcards script defined in the project.clj.&lt;/p&gt;&lt;p&gt;Unlike normal CLJS libraries, you don't specify a HTML element in your cards page to render the Devcards into. So it doesn't have anything like a &lt;code&gt;&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&lt;/code&gt; that you'd normally use with Reagent or something. Indeed, you don't need to add any code to render it at all.  Just construct the cards, and require the namespaces the cards are in from something that actually gets loaded (or something that gets loaded by something that gets loaded, etc.), and Devcards library code will handle the rendering for you.&lt;/p&gt;&lt;p&gt;That namespace point is important and easy to miss. While you don't have to explicitly render Devcards, you do have to have the namespace a card is defined in somewhere in the dependency tree of your main namespace (&lt;a href='https://github.com/clojure/clojurescript/wiki/Compiler-Options#main'&gt;main namespace mainly used for no-optimization compilation&lt;/a&gt;). So my dependency tree looks something like this: &lt;/p&gt;&lt;pre&gt;&lt;code&gt;statspop.dev  &amp;#40;the main namespace specified in project.clj&amp;#41;
|
 -- requires statspop.core
 |
  ---- requires all the application code namespaces
 -- requires statspop.core-test
 |
  ---- requires all the individual test namespaces &amp;#40;where Devcards cards and tests are defined&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Speaking of rendering, the Devcards docs suggest setting up your main app rendering with a conditional, so that it only renders if the node it aims at appears. E.g., from the core.cljs one of my projects:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defn mount-root &amp;#91;&amp;#93;
  &amp;#40;when-let &amp;#91;app &amp;#40;.getElementById js/document &amp;quot;app&amp;quot;&amp;#41;&amp;#93;
    &amp;#40;r/render &amp;#91;home-page&amp;#93; app&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The idea there is that the application code (as opposed to the testing code) won't get run if the application page isn't loaded. This seems like a sensible precaution in view of the risk of side-effects, state pollution, etc.&lt;/p&gt;&lt;p&gt;That's about it for setup. &lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;using&amp;#95;devcards.&quot;&gt;&lt;/a&gt;Using devcards.&lt;/h2&gt;&lt;p&gt;I just copypasta-boilerplate import everything I might ever need into every test namespace, e.g., &lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;ns statspop.download-test
  &amp;#40;:require &amp;#91;statspop.download :as d&amp;#93; ; the functionality I want to test
            &amp;#91;cljs.test :as t :refer-macros &amp;#91;is testing&amp;#93;&amp;#93;
            &amp;#91;devcards.core :as dc :refer-macros &amp;#91;defcard deftest defcard-rg&amp;#93;&amp;#93;
            &amp;#91;reagent.core :as r&amp;#93;
            &amp;#91;cljs.test :as t :refer-macros &amp;#91;is testing&amp;#93;&amp;#93;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;After all, this is a dev build, it doesn't need to be light. &lt;/p&gt;&lt;p&gt;Then usage is super simple.  To define an ordinary test, you just do it exactly as you would with JVM clojure.test. Devcards deftest just shadows the cljs.test symbol and emits both tests for devcards and ordinary cljs tests if you also want to do the test runner thing with Phantom.js and the like for some reason. For example, I've rolled my own quick-and-dirty CSV converter rather than bring in a whole library for one function, so that needs a test: &lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;deftest nested-vectors-to-csv-string
  &amp;#40;is &amp;#40;=
       &amp;#40;d/format-vec-as-csv &amp;#91;&amp;#91;&amp;quot;foo&amp;quot; &amp;quot;bar&amp;quot;&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;&amp;quot;baz&amp;quot; 3&amp;#93;&amp;#93;&amp;#41;
       &amp;quot;foo,bar\n1,2\nbaz,3&amp;quot;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To define a card, you use the defcard macro. This is mostly useful for ui/io/other state-y and side-effect-y-type things where automated testing won't work, you really just need to look and see that the input and output are what they should be.  There's also a defcard-rg macro that is just like defcard, but will take and render Reagent components for you; I tend to use that for all cards just to keep consistency with everything else I'm doing (since I'm aggressively reagent-for-everything). So this bit of code tests the creation of a downloadable csv file based on a Reagent component in my application code: &lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;defcard-rg download-csv
  &amp;quot;download a csv file named data.csv containing the contents of the csv test above&amp;quot;
  &amp;#91;:div
   &amp;#91;:p
    &amp;#91;d/downloader &amp;#91;&amp;#91;&amp;quot;foo&amp;quot; &amp;quot;bar&amp;quot;&amp;#93; &amp;#91;1 2&amp;#93; &amp;#91;&amp;quot;baz&amp;quot; 3&amp;#93;&amp;#93; :csv&amp;#93;&amp;#93;&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note how they have docstrings and cool stuff like that too.&lt;br /&gt;&lt;/p&gt;&lt;p&gt;That's it!  (Obviously, there are advanced functions, but this is the basic stuff.)  Now you can build your devcards build (e.g. &lt;code&gt;lein figwheel devcards&lt;/code&gt; &amp;mdash;although Figwheel is much nicer wrapped in rlwrap or &lt;a href='https://paultopia.github.io/posts-output/figwheel-emacs/'&gt;used from Emacs&lt;/a&gt;), go to your cards.html or whatever page, and you'll get a lovely menu of namespaces; click on a namespace to open it and you'll see all your tests + all your cards on the page. With the examples above, I can check that my csv string conversion test passes, and I can also try out the csv downloader functionality and make sure the csv that gets downloaded looks like it should. &lt;/p&gt;&lt;p&gt;Sweet, you've got a test system. &lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Sat, 03 Dec 2016 00:00:00 -0600
</pubDate>
</item>
<item>
<guid>
http://paultopia.github.io/posts-output/figwheel-emacs/
</guid>
<link>
http://paultopia.github.io/posts-output/figwheel-emacs/
</link>
<title>
Figwheel + Spacemacs
</title>
<description>
 &lt;p&gt;I've been trying to figure out how to get Figwheel and Spacemacs to play nicely together for a while.  It turns out it's much easier than it looks (required knowledge level: reasonable comfort with front-end Clojurescript and leiningen, prior use of Figwheel, successful installation of Spacemacs and use of Clojure mode).&lt;/p&gt;&lt;p&gt;Relevant documentation: &lt;a href='https://github.com/syl20bnr/spacemacs/tree/master/layers/%2Blang/clojure'&gt;Using the Clojure layer in Spacemacs&lt;/a&gt;, &lt;a href='https://github.com/bhauman/lein-figwheel/wiki/Using-the-Figwheel-REPL-within-NRepl'&gt;using Figwheel in nREPL&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;That later document gives a process for integrating Figwheel into Emacs that doesn't seem to work with my Spacemacs stuff. But most of what it says to do isn't actually necessary, and I've extracted from it a method that doesn't actually require any special configuration in your .spacemacs, other than having Clojure mode activated.  Here's the entirety of my clojure configuration from my .spacemacs, none of which is necessary to get figwheel going: &lt;/p&gt;&lt;pre&gt;&lt;code&gt;  &amp;#40;spacemacs/toggle-evil-cleverparens-on&amp;#41;
  &amp;#40;add-hook 'clojure-mode-hook #'evil-cleverparens-mode&amp;#41;
  &amp;#40;setq cider-show-error-buffer nil&amp;#41;
  &amp;#40;with-eval-after-load 'clojure-mode
    &amp;#40;dolist &amp;#40;c &amp;#40;string-to-list &amp;quot;:&amp;#95;-?!#&amp;#42;&amp;quot;&amp;#41;&amp;#41;
      &amp;#40;modify-syntax-entry c &amp;quot;w&amp;quot; clojure-mode-syntax-table &amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So how do we do it?&lt;br /&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Step 1&lt;/strong&gt;: make sure the right stuff is in your project.clj (I have no ideas for boot users).  First, you need all the appropriate configuration for Figwheel. I usually start CLJS projects with the excellent &lt;a href='https://github.com/reagent-project/reagent-frontend-template'&gt;reagent frontend template&lt;/a&gt;, which handles most of that stuff for you. But in case you need something better, here are some of the basics that I have in my project.cljs: &lt;/p&gt;&lt;p&gt;&lt;em&gt;Figwheel in plugins&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;  :plugins &amp;#91;&amp;#91;lein-cljsbuild &amp;quot;1.1.4&amp;quot;&amp;#93;
            &amp;#91;lein-figwheel &amp;quot;0.5.8&amp;quot;&amp;#93;&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;Figwheel settings giving nrepl middleware, ports (might not be needed?), etc.&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;  :figwheel {:http-server-root &amp;quot;public&amp;quot;
             :nrepl-port 7002
             :nrepl-middleware &amp;#91;&amp;quot;cemerick.piggieback/wrap-cljs-repl&amp;quot;&amp;#93;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;CLJS builds giving source paths, e.g.:&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;  :cljsbuild {:builds {:app
                       {:source-paths &amp;#91;&amp;quot;src&amp;quot; &amp;quot;env/dev/cljs&amp;quot;&amp;#93;  ; needed
                        :compiler
                        {:main &amp;quot;blahblahblah.dev&amp;quot; ; blah blah etc.}}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;repl-options summoning up piggieback&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;  :repl-options {:nrepl-middleware &amp;#91;cemerick.piggieback/wrap-cljs-repl&amp;#93;}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;and a dev profile calling in piggieback and figwheel-sidecar&lt;/em&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;  :profiles {:dev {:dependencies &amp;#91;&amp;#91;figwheel-sidecar &amp;quot;0.5.4-5&amp;quot;&amp;#93;
                                  &amp;#91;org.clojure/tools.nrepl &amp;quot;0.2.12&amp;quot;&amp;#93;
                                  &amp;#91;com.cemerick/piggieback &amp;quot;0.2.2-SNAPSHOT&amp;quot;&amp;#93;&amp;#93;}}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Not all this stuff may be required (and my process is a little cargo-cultey), but at least the piggieback, sidecar, and source paths elements are required per the figwheel docs. If you work from the reagent frontend template, the only thing you need to add is the :repl-options section in the defproject. &lt;/p&gt;&lt;p&gt;&lt;strong&gt;Step 2&lt;/strong&gt;: then you're actually done!  Now you can activate figwheel from within emacs.  And you don't need to mess around with jacking-in clojurescript separate from clojure or anything silly like that.  Instead, you need only: &lt;/p&gt;&lt;ol&gt;&lt;li&gt;Open a cljs source file from your project.&lt;/li&gt;&lt;li&gt;Start a normal clojure repl with &lt;code&gt;SPC m s i&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Open up the CIDER REPL buffer (if it isn't up already, just use &lt;code&gt;SPC w -&lt;/code&gt; to get a new window, then &lt;code&gt;SPC b b&lt;/code&gt; to get a menu of buffers).  Now you have a cider repl, a CLJ/JVM one rather than a CLJS/JS one.&lt;/li&gt;&lt;li&gt;In the cider repl, call the following three functions in order:&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;use 'figwheel-sidecar.repl-api&amp;#41;

&amp;#40;start-figwheel!&amp;#41;

&amp;#40;cljs-repl&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And now you have a Figwheel REPL in the buffer.  You can send stuff to the browser just like you can with Figwheel in the terminal, AND you can use the normal spacemacs/cider key bindings to send stuff to the fancy figwheel repl through emacs. &lt;/p&gt;&lt;p&gt;Even more awesome, you can then quit out of the cljs repl with &lt;code&gt;:cljs/quit&lt;/code&gt;, at which point you'll have a clj repl again, and you can send CLJ/JVM code to that as normal.  BUT: figwheel will still be autobuilding!  So you can edit your cljs code and it'll shoot right back to the browser.  Then, when you want a figwheel repl again, you can go with &lt;code&gt;&amp;#40;cljs-repl&amp;#41;&lt;/code&gt; and it'll be right back.&lt;/p&gt;&lt;p&gt;When you kill cider (with &lt;code&gt;SPC m s q&lt;/code&gt;) it's polite enough to also take out the figwheel autobuild. &lt;/p&gt;&lt;p&gt;Magic. &lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Fri, 02 Dec 2016 00:00:00 -0600
</pubDate>
</item>
<item>
<guid>
http://paultopia.github.io/posts-output/helloworld/
</guid>
<link>
http://paultopia.github.io/posts-output/helloworld/
</link>
<title>
Cryogen + Github pages + Klipse
</title>
<description>
&lt;p&gt;Hello world, and all that jazz.  I've decided to start a tech blog. &lt;/p&gt;&lt;p&gt;The first challenge: getting it up. Static site generators seem to be fashionable these days, and I'm a big fan of Clojure, so naturally I went with &lt;a href='http://cryogenweb.org/'&gt;Cryogen&lt;/a&gt;, which is a dead simple static site generator where you literally fire up a lein template and then edit a bunch of markdown files and simple &lt;a href='https://github.com/yogthos/Selmer'&gt;Selmer&lt;/a&gt; templates plus a single config edn. And &lt;a href='https://pages.github.com/'&gt;Github Pages&lt;/a&gt; is both free and convenient name recognition for code-oriented things, so that's the obvious choice for a host.&lt;/p&gt;&lt;p&gt;The main alternative I considered was &lt;a href='https://jaspervdj.be/hakyll/'&gt;Hakyll&lt;/a&gt;, mainly because I've been meaning to try to do a Haskell project. But taking one look at the code in the &quot;create compilation rules in a Haskell EDSL&quot; snippet on the front page, and, nopesauce. As much as I'm starting to like Haskell (more later), I still immediately get turned off by the weird &lt;a href='https://twitter.com/PaulGowder/status/783886798350987264'&gt;special character-heavy syntax choices&lt;/a&gt;. So when I saw &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; and &lt;code&gt;.||.&lt;/code&gt; that was it for me. (Maybe when I finally write my personal course management system.)&lt;/p&gt;&lt;p&gt;So challenge #1 is getting it on github. The official Cryogen docs aren't terribly clear on this point, but github personal/organizational pages appear to want to have the static content at the root of the repo, and Cryogen outputs the content it produces to /resources/public. You can fix this by setting the repo at resources/public rather than in the root directory of the Cryogen project, but then the markdown files, Selmer templates, etc. aren't under version control, and that's obviously a problem.&lt;/p&gt;&lt;p&gt;Fortunately, a couple nice chaps named &lt;a href='http://tangrammer.github.io/posts/02-12-2014-cryogen-and-github.html'&gt;Juan Ruz&lt;/a&gt; and Mayank Jain cooked up &lt;a href='http://firesofmay.com/posts/2015-08-26-setup-cryogen.html'&gt;a solution&lt;/a&gt;. The heart of the fix is to create one repo at the root of the Cryogen project, call it &quot;my blog&quot; or something, and then create a second repo, &lt;em&gt;inside the first one&lt;/em&gt;, with the standard yourname.github.io naming, starting at /resources/public. &lt;/p&gt;&lt;p&gt;To be honest, this seems super-shady to me. The official way to nest repositories in one another in git is to use a &lt;a href='https://git-scm.com/docs/git-submodule'&gt;submodule&lt;/a&gt;, but just try to read the documentation for that, I dare you. So what happens if you actually nest repos like this without using submodules?  Does everything horribly break?  Well, not so far... &lt;/p&gt;&lt;p&gt;The folks who devised this recommend putting /resources/public in the .gitignore of the original repo, presumably as a safety measure to prevent all kinds of weird conflicts from happening. And it seems ok... I haven't horribly blown up anything so far. (Heaven help me if I try to do anything even remotely fancy with branches, or checking out old commits, or something.)&lt;/p&gt;&lt;p&gt;The second challenge is getting Klipse running. For those who don't know, &lt;a href='https://github.com/viebel/klipse'&gt;Klipse&lt;/a&gt; is an amazing embedded clojurescript evaluation environment, basically a modular repl in a page: you can replace code snippets with actual executable code, and even do things like fetch libraries. It is awesomesauce. It also has interpreters for (officially) Javascript, Ruby, and PHP in addition to clojurescript; unofficially it also has Python among others. &lt;/p&gt;&lt;p&gt;After some hassle, integrating Klipse with Cryogen actually turned out to be dead simple. In Cryogen, all the Selmer templates are stored in subdirectories of your themes, so all I did was &lt;a href='https://github.com/paultopia/experimental-cryogen/blob/master/resources/templates/themes/nucleus/html/base.html'&gt;edit base.html&lt;/a&gt; there to add references to the Klipse javascript source.  Viz: &lt;/p&gt;&lt;pre&gt;&lt;code&gt;{% if post.executable %}
{% style &amp;quot;css/codemirror.css&amp;quot; %}
&amp;lt;script&amp;gt;
 window.klipse&amp;#95;settings = {
     selector: '.clojure',
     selector&amp;#95;eval&amp;#95;python&amp;#95;client: '.python'
 };
&amp;lt;/script&amp;gt;
{% script &amp;quot;js/klipse&amp;#95;plugin.js&amp;quot; %}
{% script &amp;quot;js/skulpt.min.js&amp;quot; %}
{% script &amp;quot;js/skulpt-stdlib.js&amp;quot; %}
{% endif %}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A few points to note there: &lt;/p&gt;&lt;ul&gt;&lt;li&gt;The selectors are classes that can be added to a fenced code block in the markdown file just by putting the name of a class directly after the opening symbol, i.e., &lt;code&gt;&amp;#126;&amp;#126;&amp;#126;clojure&lt;/code&gt;&lt;/li&gt;&lt;li&gt;post.executable is a variable that I set at the top of the markdown files. So what the template does is chooses whether or not to include the Klipse stuff depending on whether I've said, in a given post, that there's executable code in it. The rationale here is that all this extra javascript is really heavy, and I don't want people to have to load it if they're just visiting the site to look at a page that doesn't use it.  I'll probably modify this down the road to take a different variable for each language, and then only load the interpretation environment appropriate to that language.&lt;/li&gt;&lt;li&gt;Because Python is still an unofficial part of Klipse, this selector isn't actually documented yet, but it's in there and I'll prove it:&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;print &amp;quot;, &amp;quot;.join&amp;#40;map&amp;#40;lambda x: &amp;quot;Hello &amp;quot; + x, &amp;#91;&amp;quot;my baby&amp;quot;, &amp;quot;my honey&amp;quot;, &amp;quot;my ragtop World!&amp;quot;&amp;#93;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;See?&lt;/p&gt;&lt;ul&gt;&lt;li&gt;I'm locally serving the Klipse javascript rather than using the one provided by the (awesome) maintainer of the plugin because the provided version doesn't support https. However, it turns out there's &lt;a href='https://github.com/viebel/klipse#https'&gt;a workaround&lt;/a&gt;, and I'll probably switch to that, because the maintainer told me that he's pushing out frequent releases, and I want to keep up to date.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Other matters of note: &lt;/p&gt;&lt;ul&gt;&lt;li&gt;Depending on what languages you want to use, you might need a special build of the highlight.js javascript that comes with cryogen. &lt;a href='https://highlightjs.org/download/'&gt;Get it here&lt;/a&gt;.&lt;/li&gt;&lt;li&gt;All this mucking around with multiple repos and such really demands &lt;a href='https://github.com/paultopia/experimental-cryogen/blob/master/deploy'&gt;a build script&lt;/a&gt;.  Mostly derived from Jain's.&lt;/li&gt;&lt;li&gt;Note how you can compile Cryogen with &lt;code&gt;lein run&lt;/code&gt;. This isn't actually in the documentation anywhere, which just recommends compiling with &lt;code&gt;lein ring server&lt;/code&gt; and actually running a whole webserver (plus auto recompile). But this seems annoying and wasteful to me when you can just add a compilation step to the build script.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Now let's have a fizzbuzz.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;take 100 &amp;#40;map #&amp;#40;cond &amp;#40;= &amp;#40;mod % 15&amp;#41; 0&amp;#41; &amp;quot;fizzbuzz&amp;quot; &amp;#40;= &amp;#40;mod % 3&amp;#41; 0&amp;#41; &amp;quot;fizz&amp;quot; &amp;#40;= &amp;#40;mod % 5&amp;#41; 0&amp;#41; &amp;quot;buzz&amp;quot; :else %&amp;#41; &amp;#40;range 1 101&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;bye.&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Mon, 17 Oct 2016 00:00:00 -0500
</pubDate>
</item>
<item>
<guid>
http://paultopia.github.io/posts-output/second/
</guid>
<link>
http://paultopia.github.io/posts-output/second/
</link>
<title>
Experimenting
</title>
<description>
&lt;p&gt;This is just a post to experiment with klipse and making it work with cryogen markdown passing. &lt;/p&gt;&lt;p&gt;the following is done with markdown fenced block: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;take 10 &amp;#40;map inc &amp;#40;range&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;the following is done with raw html code tags:&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;clojure&quot;&gt; ((comp (partial apply +) (partial map (partial * 3))) [1 2 3]) &lt;/code&gt;&lt;/p&gt;&lt;p&gt;Doing some haskell to see default highlight.js behavior:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;plength :: &amp;#91;a&amp;#93; -&amp;gt; Int
plength &amp;#91;&amp;#93; = 0
plength &amp;#40;x:xs&amp;#41; = 1 + plength xs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Some python with markdown fenced block:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;for x in range&amp;#40;20&amp;#41;:
    print x
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With raw code tag:&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;python&quot;&gt;print [x.upper() for x in [&quot;foo&quot;, &quot;bar&quot;]] &lt;/code&gt;&lt;/p&gt;&lt;p&gt;(need to minimize loading of plugins by having a tag for each language)&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Sun, 16 Oct 2016 00:00:00 -0500
</pubDate>
</item>
<item>
<guid>
http://paultopia.github.io/posts-output/2016-01-07-docs/
</guid>
<link>
http://paultopia.github.io/posts-output/2016-01-07-docs/
</link>
<title>
Quick Start Guide
</title>
<description>
&lt;p&gt;This intro only documents a subset of Cryogen's features. For additional documentation please see the &lt;a href='http://cryogenweb.org'&gt;cryogen site&lt;/a&gt;.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;features&quot;&gt;&lt;/a&gt;Features&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Blog posts and pages with Markdown (default) or AsciiDoc&lt;/li&gt;&lt;li&gt;Tags&lt;/li&gt;&lt;li&gt;Table of contents generation&lt;/li&gt;&lt;li&gt;Plain HTML page templates&lt;/li&gt;&lt;li&gt;Code syntax highlighting&lt;/li&gt;&lt;li&gt;Disqus support&lt;/li&gt;&lt;li&gt;Sitemap generation&lt;/li&gt;&lt;li&gt;RSS feed generation&lt;/li&gt;&lt;li&gt;Sass/SCSS compilation&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;prerequisites&quot;&gt;&lt;/a&gt;Prerequisites&lt;/h2&gt;&lt;p&gt;You will need &lt;a href='https://github.com/technomancy/leiningen'&gt;Leiningen&lt;/a&gt; 2.5.0 or above installed.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;usage&quot;&gt;&lt;/a&gt;Usage&lt;/h2&gt;&lt;h3&gt;&lt;a name=&quot;creating&amp;#95;a&amp;#95;new&amp;#95;site&quot;&gt;&lt;/a&gt;Creating a New Site&lt;/h3&gt;&lt;p&gt;A new site can be created using the Cryogen template as follows:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;lein new cryogen my-blog
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;running&amp;#95;the&amp;#95;server&quot;&gt;&lt;/a&gt;Running the Server&lt;/h3&gt;&lt;p&gt;The web server can be started from the &lt;code&gt;my-blog&lt;/code&gt; directory using the &lt;code&gt;lein-ring&lt;/code&gt; plugin:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;lein ring server
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The server will watch for changes in the &lt;code&gt;resources/templates&lt;/code&gt; folder and recompile the content automatically.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;site&amp;#95;configuration&quot;&gt;&lt;/a&gt;Site Configuration&lt;/h3&gt;&lt;p&gt;The site configuration file is found at &lt;code&gt;templates/config.edn&lt;/code&gt;, this file looks as follows:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:site-title         &amp;quot;My Awesome Blog&amp;quot;
 :author             &amp;quot;Bob Bobbert&amp;quot;
 :description        &amp;quot;This blog is awesome&amp;quot;
 :site-url           &amp;quot;http://blogawesome.com/&amp;quot;
 :post-root          &amp;quot;posts&amp;quot;
 :page-root          &amp;quot;pages&amp;quot;
 :post-root-uri      &amp;quot;posts-output&amp;quot;
 :page-root-uri      &amp;quot;pages-output&amp;quot;
 :tag-root-uri       &amp;quot;tags-output&amp;quot;
 :blog-prefix        &amp;quot;/blog&amp;quot;
 :rss-name           &amp;quot;feed.xml&amp;quot;
 :rss-filters        &amp;#91;&amp;quot;cryogen&amp;quot;&amp;#93;
 :recent-posts       3
 :post-date-format   &amp;quot;yyyy-MM-dd&amp;quot;
 :sass-src           nil
 :sass-dest          nil
 :theme              &amp;quot;blue&amp;quot;
 :resources          &amp;#91;&amp;quot;img&amp;quot;&amp;#93;
 :keep-files         &amp;#91;&amp;quot;.git&amp;quot;&amp;#93;
 :disqus?            false
 :disqus-shortname   &amp;quot;&amp;quot;
 :ignored-files      &amp;#91;#&amp;quot;\.#.&amp;#42;&amp;quot; #&amp;quot;.&amp;#42;\.swp$&amp;quot;&amp;#93;
 :posts-per-page     5
 :blocks-per-preview 2
 :previews?          false
 :clean-urls?        true}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For information about each key please see the &lt;a href='http://cryogenweb.org/docs/configuration.html'&gt;&quot;Configuration&quot;&lt;/a&gt; portion of the Cryogen documentation site.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;switching&amp;#95;between&amp;#95;markdown&amp;#95;and&amp;#95;asciidoc&quot;&gt;&lt;/a&gt;Switching between Markdown and AsciiDoc&lt;/h3&gt;&lt;p&gt;Cryogen comes with Markdown support as default. If you want to use AsciiDoc instead, open the &lt;code&gt;project.clj&lt;/code&gt; in your created blog (e.g. &lt;code&gt;my-blog&lt;/code&gt;), and change the line in &lt;code&gt;:dependencies&lt;/code&gt; that says &lt;code&gt;cryogen-markdown&lt;/code&gt; to &lt;code&gt;cryogen-asciidoc&lt;/code&gt;. Instead of looking for files ending in &lt;code&gt;.md&lt;/code&gt; in the &lt;code&gt;resources/templates/md&lt;/code&gt; directory, the compiler will now look for files ending in &lt;code&gt;.asc&lt;/code&gt; in the &lt;code&gt;resources/templates/asc&lt;/code&gt; directory.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;selecting&amp;#95;a&amp;#95;theme&quot;&gt;&lt;/a&gt;Selecting a Theme&lt;/h3&gt;&lt;p&gt;The Cryogen template comes with two themes in the &lt;code&gt;resources/templates/themes&lt;/code&gt; folder. To change your blog's theme, change the value of the &lt;code&gt;:theme&lt;/code&gt; key in &lt;code&gt;config.edn&lt;/code&gt;.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;customizing&amp;#95;layouts&quot;&gt;&lt;/a&gt;Customizing Layouts&lt;/h3&gt;&lt;p&gt;Cryogen uses &lt;a href='https://github.com/yogthos/Selmer'&gt;Selmer&lt;/a&gt; templating engine for layouts. Please refer to its documentation to see the supported tags and filters for the layouts.&lt;/p&gt;&lt;p&gt;The layouts are contained in the &lt;code&gt;resources/templates/themes/{theme}/html&lt;/code&gt; folder of the project. By default, the &lt;code&gt;base.html&lt;/code&gt; layout is used to provide the general layout for the site. This is where you would add static resources such as CSS and JavaScript assets as well as define headers and footers for your site.&lt;/p&gt;&lt;p&gt;Each page layout should have a name that matches the &lt;code&gt;:layout&lt;/code&gt; key in the page metadata and end with &lt;code&gt;.html&lt;/code&gt;. Page layouts extend the base layout and should only contain the content relevant to the page inside the &lt;code&gt;content&lt;/code&gt; block. For example, the &lt;code&gt;tag&lt;/code&gt; layout is located in &lt;code&gt;tag.html&lt;/code&gt; and looks as follows:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;{% extends &amp;quot;templates/html/layouts/base.html&amp;quot; %}
{% block content %}
&amp;lt;div id=&amp;quot;posts-by-tag&amp;quot;&amp;gt;
    &amp;lt;h2&amp;gt;Posts tagged {{name}}&amp;lt;/h2&amp;gt;
    &amp;lt;ul&amp;gt;
    {% for post in posts %}
        &amp;lt;li&amp;gt;
            &amp;lt;a href=&amp;quot;{{post.uri}}&amp;quot;&amp;gt;{{post.title}}&amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;
    {% endfor %}
    &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;code&amp;#95;syntax&amp;#95;highlighting&quot;&gt;&lt;/a&gt;Code Syntax Highlighting&lt;/h3&gt;&lt;p&gt;Cryogen uses &lt;a href='https://highlightjs.org/'&gt;Highlight.js&lt;/a&gt; for code syntax highlighting. You can add more languages by replacing &lt;code&gt;templates/js/highlight.pack.js&lt;/code&gt; with a customized package from &lt;a href='https://highlightjs.org/download/'&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;The &lt;code&gt; initHighlightingOnLoad&lt;/code&gt; function is called in &lt;code&gt;{theme}/html/base.html&lt;/code&gt;.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;xml&quot;&gt;&amp;lt;script&amp;gt;hljs.initHighlightingOnLoad&amp;#40;&amp;#41;;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;deploying&amp;#95;your&amp;#95;site&quot;&gt;&lt;/a&gt;Deploying Your Site&lt;/h2&gt;&lt;p&gt;The generated static content will be found under the &lt;code&gt;resources/public&lt;/code&gt; folder. Simply copy the content to a static folder for a server such as Nginx or Apache and your site is now ready for service.&lt;/p&gt;&lt;p&gt;A sample Nginx configuration that's placed in &lt;code&gt;/etc/nginx/sites-available/default&lt;/code&gt; can be seen below:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;server {
  listen 80 default&amp;#95;server;
  listen &amp;#91;::&amp;#93;:80 default&amp;#95;server ipv6only=on;
  server&amp;#95;name localhost &amp;lt;yoursite.com&amp;gt; &amp;lt;www.yoursite.com&amp;gt;;

  access&amp;#95;log  /var/log/blog&amp;#95;access.log;
  error&amp;#95;log   /var/log/blog&amp;#95;error.log;

  location / {
    alias       /var/blog/;
    error&amp;#95;page  404 = /404.html;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Simply set &lt;code&gt;yoursite.com&lt;/code&gt; to the domain of your site in the above configuration and ensure the static content is available at &lt;code&gt;/var/blog/&lt;/code&gt;. Finally, place your custom error page in the &lt;code&gt;/var/blog/404.html&lt;/code&gt; file.&lt;/p&gt;&lt;p&gt;More information on deployment can be found &lt;a href='http://cryogenweb.org/docs/deploying-to-github-pages.html'&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;some&amp;#95;sites&amp;#95;made&amp;#95;with&amp;#95;cryogen&quot;&gt;&lt;/a&gt;Some Sites Made With Cryogen&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='http://carmenla.me/blog/index.html'&gt;Creator's blog&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://cryogenweb.org'&gt;Cryogen Documentation Site&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://yogthos.net/'&gt;Yogthos' blog&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://www.clojure.tn'&gt;Clojure :in Tunisia&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://dl1ely.github.io'&gt;dl1ely.github.io&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://jonase.github.io/nil-recur'&gt;nil/recur&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://tangrammer.github.io/'&gt;on the clojure move&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://blog.jethrokuan.com/'&gt;cognizance&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://www.agynamix.de'&gt;AGYNAMIX Site &amp; Blog&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://eresident.me'&gt;e-Resident Me&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://www.chadstovern.com'&gt;Chad Stovern's blog&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://greative.jp/'&gt;Greative&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Thu, 07 Jan 2016 00:00:00 -0600
</pubDate>
</item>
<item>
<guid>
http://paultopia.github.io/posts-output/2014-11-04-second-post/
</guid>
<link>
http://paultopia.github.io/posts-output/2014-11-04-second-post/
</link>
<title>
Yet Another Post
</title>
<description>
&lt;h3&gt;&lt;a name=&quot;this&amp;#95;post&amp;#95;so&amp;#95;fetch&quot;&gt;&lt;/a&gt;This Post So Fetch&lt;/h3&gt;&lt;p&gt;some more stuff happened&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Tue, 04 Nov 2014 00:00:00 -0600
</pubDate>
</item>
<item>
<guid>
http://paultopia.github.io/posts-output/2014-03-10-first-post/
</guid>
<link>
http://paultopia.github.io/posts-output/2014-03-10-first-post/
</link>
<title>
A Post
</title>
<description>
&lt;h3&gt;&lt;a name=&quot;this&amp;#95;post&amp;#95;not&amp;#95;fetch&amp;#95;enough&quot;&gt;&lt;/a&gt;This Post Not Fetch Enough&lt;/h3&gt;&lt;p&gt;some stuff happened&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;and a quote appeared &lt;/p&gt;&lt;/blockquote&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Mon, 10 Mar 2014 00:00:00 -0500
</pubDate>
</item>
</channel>
</rss>
